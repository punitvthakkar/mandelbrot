// ============================================================================
// HYBRID RENDERER: WebGL for speed, CPU+Big.js for deep zoom precision
// ============================================================================

// Precision threshold: switch to CPU rendering when zoom exceeds this
const PRECISION_THRESHOLD_ZOOM = 100000; // ~10^5x zoom

// Progressive rendering settings
const CHUNK_SIZE = 32; // Render in 32x32 pixel chunks (smaller = more responsive)
const CHUNK_DELAY = 1; // ms delay between chunks to keep UI responsive
let renderQueue = [];
let isRendering = false;

// ============================================================================
// CPU RENDERER with Big.js for arbitrary precision
// ============================================================================

function mandelbrotCPU(cx, cy, maxIter) {
    // Use Big.js for arbitrary precision
    Big.DP = 20; // 20 decimal places (sufficient for most deep zooms, much faster)
    Big.RM = Big.roundDown;
    
    const cxBig = new Big(cx);
    const cyBig = new Big(cy);
    
    let zx = new Big(0);
    let zy = new Big(0);
    
    let iter = 0;
    const bailout = 16; // Use regular number for comparison
    
    for (iter = 0; iter < maxIter; iter++) {
        // z = z^2 + c
        const zx2 = zx.times(zx);
        const zy2 = zy.times(zy);
        
        // Check bailout: |z|^2 > 16 (convert to number for fast comparison)
        const modSqNum = parseFloat(zx2.plus(zy2).toString());
        if (modSqNum > bailout) {
            // Smooth coloring
            const smoothIter = iter + 1 - Math.log(Math.log(modSqNum)) / Math.log(2);
            return { escaped: true, iter: smoothIter };
        }
        
        // z_new = z^2 + c
        const zyNew = zx.times(zy).times(2).plus(cyBig);
        const zxNew = zx2.minus(zy2).plus(cxBig);
        
        zx = zxNew;
        zy = zyNew;
    }
    
    return { escaped: false, iter: maxIter };
}

function renderChunkCPU(canvas2d, ctx, startX, startY, endX, endY, centerX, centerY, zoomSize, maxIter, paletteId) {
    const width = canvas2d.width;
    const height = canvas2d.height;
    const imageData = ctx.getImageData(startX, startY, endX - startX, endY - startY);
    const data = imageData.data;
    
    Big.DP = 20;
    const zoomSizeBig = new Big(zoomSize.toString());
    const centerXBig = new Big(centerX.toString());
    const centerYBig = new Big(centerY.toString());
    const heightBig = new Big(height);
    
    let pixelIndex = 0;
    
    for (let py = startY; py < endY; py++) {
        for (let px = startX; px < endX; px++) {
            // Map pixel to complex plane with arbitrary precision
            const uvx = new Big(px - width / 2).div(heightBig);
            const uvy = new Big(height / 2 - py).div(heightBig);
            
            const cx = centerXBig.plus(uvx.times(zoomSizeBig));
            const cy = centerYBig.plus(uvy.times(zoomSizeBig));
            
            const result = mandelbrotCPU(cx.toString(), cy.toString(), maxIter);
            
            const color = getColorCPU(result, paletteId);
            
            data[pixelIndex++] = color.r;
            data[pixelIndex++] = color.g;
            data[pixelIndex++] = color.b;
            data[pixelIndex++] = 255;
        }
    }
    
    ctx.putImageData(imageData, startX, startY);
}

function getColorCPU(result, paletteId) {
    if (!result.escaped) {
        return { r: 1, g: 1, b: 2 };
    }
    
    const t = result.iter * 0.005;
    const tMod = t % 1.0;
    
    let r, g, b;
    
    if (paletteId === 0) {
        // Ocean
        r = 127.5 + 127.5 * Math.cos(6.28318 * (tMod + 0.0));
        g = 127.5 + 127.5 * Math.cos(6.28318 * (tMod + 0.1));
        b = 127.5 + 127.5 * Math.cos(6.28318 * (tMod + 0.2));
    } else if (paletteId === 1) {
        // Magma
        const mixFactor = Math.sin(t * 15.0) * 0.5 + 0.5;
        r = 25 + 230 * mixFactor;
        g = 0 + 127 * mixFactor;
        b = 51 + 25 * mixFactor;
    } else if (paletteId === 2) {
        // Aurora
        r = 127.5 + 127.5 * Math.cos(6.28318 * (tMod + 0.0));
        g = 127.5 + 127.5 * Math.cos(6.28318 * (tMod * 0.7 + 0.15));
        b = 127.5 + 127.5 * Math.cos(6.28318 * (tMod * 0.4 + 0.2));
    } else {
        // Amber
        const blend = 0.5 + 0.5 * Math.sin(t * 12.0);
        r = 76 + 179 * blend;
        g = 25 + 179 * blend;
        b = 12 + 38 * blend;
    }
    
    return { 
        r: Math.max(0, Math.min(255, Math.floor(r))), 
        g: Math.max(0, Math.min(255, Math.floor(g))), 
        b: Math.max(0, Math.min(255, Math.floor(b))) 
    };
}

function startProgressiveRender(canvas2d, ctx, centerX, centerY, zoomSize, maxIter, paletteId) {
    const width = canvas2d.width;
    const height = canvas2d.height;
    
    // Build render queue
    renderQueue = [];
    for (let y = 0; y < height; y += CHUNK_SIZE) {
        for (let x = 0; x < width; x += CHUNK_SIZE) {
            renderQueue.push({
                startX: x,
                startY: y,
                endX: Math.min(x + CHUNK_SIZE, width),
                endY: Math.min(y + CHUNK_SIZE, height)
            });
        }
    }
    
    isRendering = true;
    
    // Show CPU rendering indicator
    const indicator = document.getElementById('cpuIndicator');
    indicator.classList.add('visible');
    document.getElementById('renderProgress').innerText = '0%';
    
    processRenderQueue(canvas2d, ctx, centerX, centerY, zoomSize, maxIter, paletteId);
}

function processRenderQueue(canvas2d, ctx, centerX, centerY, zoomSize, maxIter, paletteId) {
    if (renderQueue.length === 0 || !isRendering) {
        isRendering = false;
        console.log('CPU rendering complete');
        
        // Hide CPU rendering indicator
        const indicator = document.getElementById('cpuIndicator');
        indicator.classList.remove('visible');
        
        return;
    }
    
    const chunk = renderQueue.shift();
    
    // Show progress
    const totalChunks = Math.ceil(canvas2d.width / CHUNK_SIZE) * Math.ceil(canvas2d.height / CHUNK_SIZE);
    const remaining = renderQueue.length;
    const progress = Math.floor(((totalChunks - remaining) / totalChunks) * 100);
    
    // Update progress indicator
    document.getElementById('renderProgress').innerText = `${progress}%`;
    
    renderChunkCPU(canvas2d, ctx, chunk.startX, chunk.startY, chunk.endX, chunk.endY, 
                   centerX, centerY, zoomSize, maxIter, paletteId);
    
    // Add small delay to keep UI responsive
    setTimeout(() => {
        requestAnimationFrame(() => {
            processRenderQueue(canvas2d, ctx, centerX, centerY, zoomSize, maxIter, paletteId);
        });
    }, CHUNK_DELAY);
}

function stopProgressiveRender() {
    isRendering = false;
    renderQueue = [];
    
    // Hide CPU rendering indicator
    const indicator = document.getElementById('cpuIndicator');
    if (indicator) {
        indicator.classList.remove('visible');
    }
}


// ============================================================================
// WebGL RENDERER (Original - for low/medium zoom)
// ============================================================================

// Shaders
const vsSource = `
    attribute vec4 aVertexPosition;
    void main() {
        gl_Position = aVertexPosition;
    }
`;

const fsSource = `
    precision highp float;

    uniform vec2 u_resolution;
    // Double precision emulation: .x = high, .y = low
    uniform vec2 u_zoomCenter_x; 
    uniform vec2 u_zoomCenter_y;
    uniform vec2 u_zoomSize;
    uniform int u_maxIterations;
    uniform int u_paletteId;

    // Emulated double math functions
    vec2 ds_add(vec2 dsa, vec2 dsb) {
        vec2 dsc;
        float t1, t2, e;
        t1 = dsa.x + dsb.x;
        e = t1 - dsa.x;
        t2 = ((dsb.x - e) + (dsa.x - (t1 - e))) + dsa.y + dsb.y;
        dsc.x = t1 + t2;
        dsc.y = t2 - (dsc.x - t1);
        return dsc;
    }

    vec2 ds_sub(vec2 dsa, vec2 dsb) {
        vec2 dsc;
        float t1, t2, e;
        t1 = dsa.x - dsb.x;
        e = t1 - dsa.x;
        t2 = ((-dsb.x - e) + (dsa.x - (t1 - e))) + dsa.y - dsb.y;
        dsc.x = t1 + t2;
        dsc.y = t2 - (dsc.x - t1);
        return dsc;
    }

    vec2 ds_mul(vec2 dsa, vec2 dsb) {
        vec2 dsc;
        float c11, c21, c2, e, t1, t2;
        float a1, a2, b1, b2, cona, conb, split = 8193.0;
        
        cona = dsa.x * split;
        a1 = cona - (cona - dsa.x);
        a2 = dsa.x - a1;
        
        conb = dsb.x * split;
        b1 = conb - (conb - dsb.x);
        b2 = dsb.x - b1;
        
        c11 = dsa.x * dsb.x;
        c21 = a1 * b1 - c11;
        c21 += a1 * b2;
        c21 += a2 * b1;
        c21 += a2 * b2;
        
        c2 = dsa.x * dsb.y + dsa.y * dsb.x;
        
        t1 = c11 + c2;
        e = t1 - c11;
        t2 = dsa.y * dsb.y + ((c2 - e) + (c11 - (t1 - e))) + c21;
        
        dsc.x = t1 + t2;
        dsc.y = t2 - (dsc.x - t1);
        return dsc;
    }

    vec2 ds_set(float a) {
        return vec2(a, 0.0);
    }

    vec3 palette( float t, vec3 a, vec3 b, vec3 c, vec3 d ) {
        return a + b*cos( 6.28318*(c*t+d) );
    }

    vec3 calculateColor(vec2 uv) {
        // Convert UV to double-single
        vec2 uv_x_ds = vec2(uv.x, 0.0);
        vec2 uv_y_ds = vec2(uv.y, 0.0);

        // Calculate complex number c = center + uv * zoomSize
        vec2 c_x = ds_add(u_zoomCenter_x, ds_mul(uv_x_ds, u_zoomSize));
        vec2 c_y = ds_add(u_zoomCenter_y, ds_mul(uv_y_ds, u_zoomSize));

        vec2 z_x = vec2(0.0);
        vec2 z_y = vec2(0.0);
        
        bool escaped = false;
        int iterations = 0;
        float final_modZ = 0.0;

        for (int i = 0; i < 10000; i++) {
            if (i >= u_maxIterations) break;
            
            vec2 z_x2 = ds_mul(z_x, z_x);
            vec2 z_y2 = ds_mul(z_y, z_y);
            
            if (z_x2.x + z_y2.x > 16.0) { // Higher escape radius for smoother results
                escaped = true;
                iterations = i;
                final_modZ = sqrt(z_x2.x + z_y2.x);
                break;
            }

            vec2 two = vec2(2.0, 0.0);
            vec2 z_xy = ds_mul(z_x, z_y);
            vec2 two_z_xy = ds_mul(two, z_xy);
            vec2 new_y = ds_add(two_z_xy, c_y);

            vec2 diff_sq = ds_sub(z_x2, z_y2);
            vec2 new_x = ds_add(diff_sq, c_x);

            z_x = new_x;
            z_y = new_y;
        }

        if (escaped) {
            // Smooth iteration count
            float smoothIter = float(iterations) + 1.0 - log(log(final_modZ)) / log(2.0);
            
            // Slow down the color cycle for smoother gradients
            float t = smoothIter * 0.005; 
            
            vec3 color = vec3(0.0);

            if (u_paletteId == 0) {
                // Electric Blue - Softer, deeper ocean tones
                color = palette(t, vec3(0.5, 0.5, 0.5), vec3(0.5, 0.5, 0.5), vec3(1.0, 1.0, 1.0), vec3(0.00, 0.10, 0.20));
                // Add soft highlight based on iteration
                color += vec3(0.05) * sin(t * 20.0);
            } else if (u_paletteId == 1) {
                // Magma - Warm, cinematic orange/purple instead of harsh red/blue
                color = palette(t, vec3(0.5), vec3(0.5), vec3(1.0, 1.0, 0.5), vec3(0.8, 0.90, 0.30));
                // Soften the mix
                vec3 deepPurple = vec3(0.1, 0.0, 0.2);
                vec3 warmOrange = vec3(1.0, 0.5, 0.1);
                float mixFactor = smoothstep(-1.0, 1.0, sin(t * 15.0));
                color = mix(deepPurple, color, 0.6) + warmOrange * mixFactor * 0.4;
            } else if (u_paletteId == 2) {
                // Aurora - Soft teals and greens, less neon
                color = palette(t, vec3(0.5, 0.5, 0.5), vec3(0.5, 0.5, 0.5), vec3(1.0, 0.7, 0.4), vec3(0.0, 0.15, 0.20));
                color = mix(color, vec3(0.0, 1.0, 0.8), 0.1); // Tint teal
            } else {
                // Golden Hour - Rich gold/amber/brown
                color = palette(t, vec3(0.5), vec3(0.5), vec3(1.0, 1.0, 1.0), vec3(0.0, 0.33, 0.67)); // Standard cosine
                // Override with custom gold blend
                vec3 gold = vec3(1.0, 0.8, 0.2);
                vec3 brown = vec3(0.3, 0.1, 0.05);
                float blend = 0.5 + 0.5 * sin(t * 12.0);
                color = mix(brown, gold, blend);
            }
            
            return color;
        } else {
            // Interior - Deep, rich black/blue
            float distFromCenter = length(uv);
            return vec3(0.005, 0.005, 0.01) * (1.0 - distFromCenter * 0.1);
        }
    }

    void main() {
        // Super-Sample Anti-Aliasing (SSAA 2x2)
        vec3 totalColor = vec3(0.0);
        
        // Offsets for 4 samples
        vec2 offsets[4];
        offsets[0] = vec2(-0.25, -0.25);
        offsets[1] = vec2( 0.25, -0.25);
        offsets[2] = vec2(-0.25,  0.25);
        offsets[3] = vec2( 0.25,  0.25);
        
        for (int i = 0; i < 4; i++) {
            vec2 uv = (gl_FragCoord.xy + offsets[i] - 0.5 * u_resolution.xy) / u_resolution.y;
            totalColor += calculateColor(uv);
        }
        
        vec3 finalColor = totalColor / 4.0;
        
        // Apply subtle vignette
        vec2 uv_center = (gl_FragCoord.xy - 0.5 * u_resolution.xy) / u_resolution.y;
        float dist = length(uv_center);
        float vignette = smoothstep(1.2, 0.5, dist); // Soft edges
        finalColor *= 0.8 + 0.2 * vignette;

        gl_FragColor = vec4(finalColor, 1.0);
    }
`;

// Main Logic
const canvasGL = document.getElementById('glCanvas');
const canvas2D = document.getElementById('canvas2d');
const gl = canvasGL.getContext('webgl', { preserveDrawingBuffer: true });
const ctx2d = canvas2D.getContext('2d', { willReadFrequently: true });

// Rendering mode
let useGPU = true;
let lastRenderMode = 'gpu';

function switchCanvas(toGPU) {
    if (toGPU) {
        canvasGL.style.display = 'block';
        canvas2D.style.display = 'none';
    } else {
        canvasGL.style.display = 'none';
        canvas2D.style.display = 'block';
    }
}

// WebGL capability check and fallback
function checkWebGLCapabilities() {
    if (!gl) {
        showFallbackMessage('WebGL is not supported in your browser. Please use a modern browser with WebGL support.');
        return false;
    }
    
    // Check for sufficient precision
    const fragmentPrecision = gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT);
    if (!fragmentPrecision || fragmentPrecision.precision < 23) {
        console.warn('Limited floating point precision detected. Deep zoom may have artifacts.');
    }
    
    return true;
}

function showFallbackMessage(message) {
    const fallbackDiv = document.createElement('div');
    fallbackDiv.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(20, 20, 20, 0.95);
        color: white;
        padding: 2rem;
        border-radius: 16px;
        border: 1px solid rgba(255, 255, 255, 0.1);
        max-width: 400px;
        text-align: center;
        z-index: 1000;
        font-family: 'Outfit', sans-serif;
    `;
    fallbackDiv.innerHTML = `
        <h3 style="margin: 0 0 1rem 0; font-size: 1.5rem;">Unable to Start</h3>
        <p style="margin: 0; line-height: 1.6;">${message}</p>
    `;
    document.body.appendChild(fallbackDiv);
}

// State
let state = {
    zoomCenter: { x: -0.75, y: 0.0 },
    zoomSize: 3.0,
    maxIterations: 500,
    paletteId: 0,
    isDragging: false,
    lastMouse: { x: 0, y: 0 },
    targetZoomCenter: { x: -0.75, y: 0.0 },
    targetZoomSize: 3.0,
    // Physics
    velocity: { x: 0, y: 0 },
    friction: 0.9,
    isAnimating: false,
    // UI state
    drawerCollapsed: false,
    onboardingStep: 0,
    onboardingVisible: true,
    tourActive: false,
    tourStep: 0,
    // Performance
    lastStatsUpdate: 0,
    statsUpdateInterval: 100, // ms
    lastUniformValues: {}
};

const locations = {
    default: { 
        x: -0.75, y: 0.0, size: 3.0,
        title: 'Home View',
        description: 'The complete Mandelbrot set in its iconic form'
    },
    seahorse: { 
        x: -0.748, y: 0.1, size: 0.01,
        title: 'Seahorse Valley',
        description: 'Delicate tendrils spiral into intricate seahorse-like patterns'
    },
    elephant: { 
        x: 0.275, y: 0.0, size: 0.01,
        title: 'Elephant Valley',
        description: 'Bulbous spirals reminiscent of elephant trunks'
    },
    spiral: { 
        x: -0.088, y: 0.654, size: 0.005,
        title: 'Triple Spiral',
        description: 'A hypnotic vortex of three intertwined spirals'
    },
    minibrot: { 
        x: -1.75, y: 0.0, size: 0.1,
        title: 'Mini Mandelbrot',
        description: 'A perfect miniature copy of the full set—fractal self-similarity'
    }
};

const onboardingSteps = [
    {
        title: 'Welcome!',
        text: 'Explore the infinite beauty of the Mandelbrot set. Drag to pan around the fractal.'
    },
    {
        title: 'Zoom In',
        text: 'Scroll your mouse wheel or use the zoom buttons to dive deeper into the fractal.'
    },
    {
        title: 'Double-Click',
        text: 'Double-click anywhere to zoom toward that point for precise exploration.'
    },
    {
        title: 'Keyboard Shortcuts',
        text: 'Press H for help, R to reset, F for fullscreen. Check the bottom for more shortcuts!'
    },
    {
        title: 'Ready to Explore!',
        text: 'Try the location presets or take the auto-tour. Enjoy your journey!'
    }
];

// Shader Program Setup
function loadShader(gl, type, source) {
    const shader = gl.createShader(type);
    gl.shaderSource(shader, source);
    gl.compileShader(shader);

    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        const info = gl.getShaderInfoLog(shader);
        console.error('Shader compilation error:', info);
        console.error('Shader type:', type === gl.VERTEX_SHADER ? 'VERTEX' : 'FRAGMENT');
        console.error('Shader source:', source);
        gl.deleteShader(shader);
        return null;
    }

    return shader;
}

function initShaderProgram(gl, vsSource, fsSource) {
    const vertexShader = loadShader(gl, gl.VERTEX_SHADER, vsSource);
    const fragmentShader = loadShader(gl, gl.FRAGMENT_SHADER, fsSource);

    if (!vertexShader || !fragmentShader) {
        console.error('Failed to compile shaders');
        return null;
    }

    const shaderProgram = gl.createProgram();
    gl.attachShader(shaderProgram, vertexShader);
    gl.attachShader(shaderProgram, fragmentShader);
    gl.linkProgram(shaderProgram);

    if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
        const info = gl.getProgramInfoLog(shaderProgram);
        console.error('Shader program linking error:', info);
        return null;
    }

    console.log('Shaders compiled and linked successfully');
    return shaderProgram;
}

const shaderProgram = initShaderProgram(gl, vsSource, fsSource);

if (!shaderProgram) {
    console.error('Failed to initialize shader program');
}

const programInfo = shaderProgram ? {
    program: shaderProgram,
    attribLocations: {
        vertexPosition: gl.getAttribLocation(shaderProgram, 'aVertexPosition'),
    },
    uniformLocations: {
        resolution: gl.getUniformLocation(shaderProgram, 'u_resolution'),
        zoomCenterX: gl.getUniformLocation(shaderProgram, 'u_zoomCenter_x'),
        zoomCenterY: gl.getUniformLocation(shaderProgram, 'u_zoomCenter_y'),
        zoomSize: gl.getUniformLocation(shaderProgram, 'u_zoomSize'),
        maxIterations: gl.getUniformLocation(shaderProgram, 'u_maxIterations'),
        paletteId: gl.getUniformLocation(shaderProgram, 'u_paletteId'),
    },
} : null;

// Helper to split double into two floats
function splitDouble(value) {
    const hi = Math.fround(value);
    const lo = value - hi;
    return [hi, lo];
}

// Buffers
const positionBuffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
const positions = [
    -1.0, 1.0,
    1.0, 1.0,
    -1.0, -1.0,
    1.0, -1.0,
];
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);

// Rendering
let isPageVisible = true;
let animationFrameId = null;
let needsFullRender = true;

function drawScene() {
    // Skip rendering if page is not visible
    if (!isPageVisible) {
        animationFrameId = requestAnimationFrame(drawScene);
        return;
    }

    // Inertia / Momentum
    if (!state.isDragging && !state.isAnimating) {
        state.targetZoomCenter.x -= state.velocity.x;
        state.targetZoomCenter.y -= state.velocity.y;

        state.velocity.x *= state.friction;
        state.velocity.y *= state.friction;

        // Stop if slow enough
        if (Math.abs(state.velocity.x) < 1e-9 && Math.abs(state.velocity.y) < 1e-9) {
            state.velocity = { x: 0, y: 0 };
        }
    }

    // Smooth interpolation
    const lerpFactor = 0.15;
    const oldZoomSize = state.zoomSize;
    const oldCenterX = state.zoomCenter.x;
    const oldCenterY = state.zoomCenter.y;
    
    state.zoomSize += (state.targetZoomSize - state.zoomSize) * lerpFactor;
    state.zoomCenter.x += (state.targetZoomCenter.x - state.zoomCenter.x) * lerpFactor;
    state.zoomCenter.y += (state.targetZoomCenter.y - state.zoomCenter.y) * lerpFactor;

    // Check if view changed significantly
    const viewChanged = Math.abs(oldZoomSize - state.zoomSize) > 1e-10 ||
                       Math.abs(oldCenterX - state.zoomCenter.x) > 1e-10 ||
                       Math.abs(oldCenterY - state.zoomCenter.y) > 1e-10;

    if (viewChanged) {
        needsFullRender = true;
    }

    resizeCanvasToDisplaySize(canvasGL);
    resizeCanvasToDisplaySize(canvas2D);

    // Determine rendering mode based on zoom level
    const currentZoom = 3.0 / state.zoomSize;
    useGPU = currentZoom < PRECISION_THRESHOLD_ZOOM && programInfo && programInfo.program;

    // Switch rendering mode if needed
    if (useGPU && lastRenderMode !== 'gpu') {
        console.log('Switching to GPU rendering');
        switchCanvas(true);
        lastRenderMode = 'gpu';
        needsFullRender = true;
        document.getElementById('renderMode').innerText = 'GPU';
        document.getElementById('renderMode').style.color = '#4f46e5';
    } else if (!useGPU && lastRenderMode !== 'cpu') {
        console.log(`Switching to CPU rendering (zoom: ${currentZoom.toFixed(1)}x) - Using Big.js for precision`);
        switchCanvas(false);
        lastRenderMode = 'cpu';
        needsFullRender = true;
        stopProgressiveRender();
        document.getElementById('renderMode').innerText = 'CPU';
        document.getElementById('renderMode').style.color = '#f59e0b';
    }

    if (needsFullRender) {
        if (useGPU) {
            renderGPU();
        } else {
            renderCPU();
        }
        needsFullRender = false;
    }

    updateStats();
    animationFrameId = requestAnimationFrame(drawScene);
}

function renderGPU() {
    if (!programInfo || !programInfo.program) return;
    
    gl.viewport(0, 0, canvasGL.width, canvasGL.height);
    gl.clearColor(0.0, 0.0, 0.0, 1.0);
    gl.clear(gl.COLOR_BUFFER_BIT);

    gl.useProgram(programInfo.program);

    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
    gl.vertexAttribPointer(programInfo.attribLocations.vertexPosition, 2, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(programInfo.attribLocations.vertexPosition);

    gl.uniform2f(programInfo.uniformLocations.resolution, canvasGL.width, canvasGL.height);

    // Guard uniforms - only update if changed
    const centerXSplit = splitDouble(state.zoomCenter.x);
    const centerYSplit = splitDouble(state.zoomCenter.y);
    const zoomSizeSplit = splitDouble(state.zoomSize);

    const centerXKey = `${centerXSplit[0]},${centerXSplit[1]}`;
    const centerYKey = `${centerYSplit[0]},${centerYSplit[1]}`;
    const zoomSizeKey = `${zoomSizeSplit[0]},${zoomSizeSplit[1]}`;

    if (state.lastUniformValues.centerX !== centerXKey) {
        gl.uniform2f(programInfo.uniformLocations.zoomCenterX, centerXSplit[0], centerXSplit[1]);
        state.lastUniformValues.centerX = centerXKey;
    }
    
    if (state.lastUniformValues.centerY !== centerYKey) {
        gl.uniform2f(programInfo.uniformLocations.zoomCenterY, centerYSplit[0], centerYSplit[1]);
        state.lastUniformValues.centerY = centerYKey;
    }
    
    if (state.lastUniformValues.zoomSize !== zoomSizeKey) {
        gl.uniform2f(programInfo.uniformLocations.zoomSize, zoomSizeSplit[0], zoomSizeSplit[1]);
        state.lastUniformValues.zoomSize = zoomSizeKey;
    }

    if (state.lastUniformValues.maxIterations !== state.maxIterations) {
        gl.uniform1i(programInfo.uniformLocations.maxIterations, state.maxIterations);
        state.lastUniformValues.maxIterations = state.maxIterations;
    }
    
    if (state.lastUniformValues.paletteId !== state.paletteId) {
        gl.uniform1i(programInfo.uniformLocations.paletteId, state.paletteId);
        state.lastUniformValues.paletteId = state.paletteId;
    }

    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
}

function renderCPU() {
    // Clear 2D canvas
    ctx2d.fillStyle = '#000';
    ctx2d.fillRect(0, 0, canvas2D.width, canvas2D.height);
    
    // Start progressive rendering
    stopProgressiveRender();
    startProgressiveRender(canvas2D, ctx2d, state.zoomCenter.x, state.zoomCenter.y, 
                          state.zoomSize, state.maxIterations, state.paletteId);
}

// Handle page visibility changes
document.addEventListener('visibilitychange', () => {
    isPageVisible = !document.hidden;
    if (isPageVisible && !animationFrameId) {
        animationFrameId = requestAnimationFrame(drawScene);
    }
});

function resizeCanvasToDisplaySize(canvas) {
    const displayWidth = canvas.clientWidth;
    const displayHeight = canvas.clientHeight;
    if (canvas.width !== displayWidth ||
        canvas.height !== displayHeight) {
        canvas.width = displayWidth;
        canvas.height = displayHeight;
    }
}

function updateStats() {
    const now = Date.now();
    if (now - state.lastStatsUpdate < state.statsUpdateInterval) return;
    state.lastStatsUpdate = now;

    document.getElementById('coordX').innerText = state.zoomCenter.x.toFixed(5);
    document.getElementById('coordY').innerText = state.zoomCenter.y.toFixed(5);
    document.getElementById('zoomLevel').innerText = `${(3.0 / state.zoomSize).toFixed(1)}×`;
}

function updateLocationStory(locationKey) {
    const loc = locations[locationKey];
    if (!loc) return;

    document.getElementById('storyTitle').innerText = loc.title;
    document.getElementById('storyDescription').innerText = loc.description;
    document.getElementById('storyCoords').innerText = `Center: ${loc.x.toFixed(3)}, ${loc.y.toFixed(2)}`;
    document.getElementById('storyZoom').innerText = `Zoom: ${(3.0 / loc.size).toFixed(1)}×`;
    
    const storyPanel = document.getElementById('locationStory');
    storyPanel.classList.add('visible');
    
    setTimeout(() => {
        storyPanel.classList.remove('visible');
    }, 5000);
}

function updateLegendGradient() {
    const gradients = [
        'linear-gradient(90deg, #001133 0%, #006699 50%, #eef 100%)',
        'linear-gradient(90deg, #220011 0%, #cc4400 40%, #ffeeaa 100%)',
        'linear-gradient(90deg, #002211 0%, #00aa88 50%, #ccffdd 100%)',
        'linear-gradient(90deg, #331100 0%, #cc8822 50%, #ffeedd 100%)'
    ];
    document.getElementById('legendGradient').style.background = gradients[state.paletteId];
}

// Interaction
function getActiveCanvas() {
    return useGPU ? canvasGL : canvas2D;
}

function handleZoom(delta, x, y) {
    const zoomFactor = 1.1;
    const activeCanvas = getActiveCanvas();

    // Default to center if no x/y provided
    if (x === undefined || y === undefined) {
        x = activeCanvas.width / 2;
        y = activeCanvas.height / 2;
    }

    // Current mouse position in complex plane
    const uvx = (x - activeCanvas.width / 2) / activeCanvas.height;
    const uvy = (activeCanvas.height - y - activeCanvas.height / 2) / activeCanvas.height;

    const wx = state.targetZoomCenter.x + uvx * state.targetZoomSize;
    const wy = state.targetZoomCenter.y + uvy * state.targetZoomSize;

    if (delta > 0) {
        state.targetZoomSize *= zoomFactor;
    } else {
        state.targetZoomSize /= zoomFactor;
    }

    // New center = MouseWorld - MouseUV * NewZoomSize
    state.targetZoomCenter.x = wx - uvx * state.targetZoomSize;
    state.targetZoomCenter.y = wy - uvy * state.targetZoomSize;
}

// Add event listeners to both canvases
[canvasGL, canvas2D].forEach(canvas => {
    canvas.addEventListener('wheel', (e) => {
        e.preventDefault();
        const delta = Math.sign(e.deltaY);
        handleZoom(delta, e.clientX, e.clientY);
        showZoomFocusRing(e.clientX, e.clientY);
    }, { passive: false });
});

// Double-click to zoom
let lastClickTime = 0;
let lastClickPos = { x: 0, y: 0 };

[canvasGL, canvas2D].forEach(canvas => {
    canvas.addEventListener('click', (e) => {
        const now = Date.now();
        const timeDiff = now - lastClickTime;
        const distance = Math.sqrt(
            Math.pow(e.clientX - lastClickPos.x, 2) + 
            Math.pow(e.clientY - lastClickPos.y, 2)
        );

        if (timeDiff < 300 && distance < 10) {
            // Double-click detected
            handleZoom(-1, e.clientX, e.clientY);
            showZoomFocusRing(e.clientX, e.clientY);
            lastClickTime = 0;
        } else {
            lastClickTime = now;
            lastClickPos = { x: e.clientX, y: e.clientY };
        }
    });
});

function showZoomFocusRing(x, y) {
    const ring = document.getElementById('zoomFocusRing');
    ring.style.left = `${x}px`;
    ring.style.top = `${y}px`;
    ring.classList.remove('fade-out');
    ring.classList.add('active');
    
    setTimeout(() => {
        ring.classList.remove('active');
        ring.classList.add('fade-out');
    }, 400);
    
    setTimeout(() => {
        ring.classList.remove('fade-out');
    }, 800);
}

// Mouse Drag
[canvasGL, canvas2D].forEach(canvas => {
    canvas.addEventListener('mousedown', (e) => {
        state.isDragging = true;
        state.isAnimating = false;
        state.velocity = { x: 0, y: 0 };
        state.lastMouse = { x: e.clientX, y: e.clientY };
    });
});

window.addEventListener('mouseup', () => {
    state.isDragging = false;
});

window.addEventListener('mousemove', (e) => {
    if (!state.isDragging) return;

    const dx = e.clientX - state.lastMouse.x;
    const dy = e.clientY - state.lastMouse.y;

    const activeCanvas = getActiveCanvas();
    const scale = state.zoomSize / activeCanvas.height;

    // Move
    state.targetZoomCenter.x -= dx * scale;
    state.targetZoomCenter.y += dy * scale;

    // Calculate velocity for inertia
    state.velocity.x = dx * scale * 0.5;
    state.velocity.y = dy * scale * 0.5;

    state.lastMouse = { x: e.clientX, y: e.clientY };
});

// Touch Support
let lastTouchDistance = 0;

[canvasGL, canvas2D].forEach(canvas => {
    canvas.addEventListener('touchstart', (e) => {
        if (e.touches.length === 1) {
            state.isDragging = true;
            state.lastMouse = { x: e.touches[0].clientX, y: e.touches[0].clientY };
        } else if (e.touches.length === 2) {
            state.isDragging = false;
            const dx = e.touches[0].clientX - e.touches[1].clientX;
            const dy = e.touches[0].clientY - e.touches[1].clientY;
            lastTouchDistance = Math.sqrt(dx * dx + dy * dy);
        }
    }, { passive: false });

    canvas.addEventListener('touchmove', (e) => {
        e.preventDefault();
        const activeCanvas = getActiveCanvas();
        
        if (e.touches.length === 1 && state.isDragging) {
            const dx = e.touches[0].clientX - state.lastMouse.x;
            const dy = e.touches[0].clientY - state.lastMouse.y;

            const scale = state.zoomSize / activeCanvas.height;

            state.targetZoomCenter.x -= dx * scale;
            state.targetZoomCenter.y += dy * scale;

            state.lastMouse = { x: e.touches[0].clientX, y: e.touches[0].clientY };
        } else if (e.touches.length === 2) {
            const dx = e.touches[0].clientX - e.touches[1].clientX;
            const dy = e.touches[0].clientY - e.touches[1].clientY;
            const distance = Math.sqrt(dx * dx + dy * dy);

            const centerX = (e.touches[0].clientX + e.touches[1].clientX) / 2;
            const centerY = (e.touches[0].clientY + e.touches[1].clientY) / 2;

            if (lastTouchDistance > 0) {
                const delta = lastTouchDistance - distance;
                handleZoom(delta * 5, centerX, centerY);
            }
            lastTouchDistance = distance;
        }
    }, { passive: false });
});


// UI Controls - Drawer toggle
document.getElementById('drawerToggle').addEventListener('click', () => {
    state.drawerCollapsed = !state.drawerCollapsed;
    document.getElementById('controlDrawer').classList.toggle('collapsed', state.drawerCollapsed);
});

// Iterations slider
document.getElementById('iterations').addEventListener('input', (e) => {
    state.maxIterations = parseInt(e.target.value);
    document.getElementById('iterValue').innerText = state.maxIterations;
});

// Palette buttons
document.querySelectorAll('.palette-btn').forEach(btn => {
    btn.addEventListener('click', (e) => {
        document.querySelectorAll('.palette-btn').forEach(b => b.classList.remove('active'));
        e.currentTarget.classList.add('active');
        state.paletteId = parseInt(e.currentTarget.dataset.palette);
        updateLegendGradient();
    });
});

// Location selector
document.getElementById('locationSelect').addEventListener('change', (e) => {
    const loc = locations[e.target.value];
    if (loc) {
        state.isAnimating = true;
        state.velocity = { x: 0, y: 0 };

        state.targetZoomCenter = { x: loc.x, y: loc.y };
        state.targetZoomSize = loc.size;

        updateLocationStory(e.target.value);

        setTimeout(() => { state.isAnimating = false; }, 1000);
    }
});

document.getElementById('resetBtn').addEventListener('click', () => {
    state.targetZoomCenter = { x: -0.75, y: 0.0 };
    state.targetZoomSize = 3.0;
    state.velocity = { x: 0, y: 0 };
    document.getElementById('locationSelect').value = 'default';
    updateLocationStory('default');
});

document.getElementById('screenshotBtn').addEventListener('click', () => {
    const activeCanvas = getActiveCanvas();
    const link = document.createElement('a');
    link.download = `mandelbrot-${Date.now()}.png`;
    link.href = activeCanvas.toDataURL();
    link.click();
});

document.getElementById('fullscreenBtn').addEventListener('click', () => {
    toggleFullscreen();
});

function toggleFullscreen() {
    if (!document.fullscreenElement) {
        document.body.requestFullscreen().catch(err => {
            console.error(`Error attempting to enable fullscreen: ${err.message}`);
        });
        document.getElementById('fullscreenLabel').innerText = 'Exit';
    } else {
        document.exitFullscreen();
        document.getElementById('fullscreenLabel').innerText = 'Full';
    }
}

// Zoom buttons with press-and-hold
let zoomInterval = null;
let zoomAcceleration = 1;

function startZoom(direction) {
    zoomAcceleration = 1;
    handleZoom(direction);
    zoomInterval = setInterval(() => {
        zoomAcceleration = Math.min(zoomAcceleration * 1.05, 3);
        for (let i = 0; i < zoomAcceleration; i++) {
            handleZoom(direction);
        }
    }, 50);
}

function stopZoom() {
    if (zoomInterval) {
        clearInterval(zoomInterval);
        zoomInterval = null;
        zoomAcceleration = 1;
    }
}

document.getElementById('zoomInBtn').addEventListener('mousedown', () => startZoom(-1));
document.getElementById('zoomInBtn').addEventListener('mouseup', stopZoom);
document.getElementById('zoomInBtn').addEventListener('mouseleave', stopZoom);
document.getElementById('zoomInBtn').addEventListener('touchstart', (e) => {
    e.preventDefault();
    startZoom(-1);
});
document.getElementById('zoomInBtn').addEventListener('touchend', stopZoom);

document.getElementById('zoomOutBtn').addEventListener('mousedown', () => startZoom(1));
document.getElementById('zoomOutBtn').addEventListener('mouseup', stopZoom);
document.getElementById('zoomOutBtn').addEventListener('mouseleave', stopZoom);
document.getElementById('zoomOutBtn').addEventListener('touchstart', (e) => {
    e.preventDefault();
    startZoom(1);
});
document.getElementById('zoomOutBtn').addEventListener('touchend', stopZoom);

// Keyboard shortcuts
document.addEventListener('keydown', (e) => {
    switch(e.key.toLowerCase()) {
        case 'h':
            toggleOnboarding();
            break;
        case 'r':
            document.getElementById('resetBtn').click();
            break;
        case 'f':
            toggleFullscreen();
            break;
        case 't':
            document.getElementById('autoTourBtn').click();
            break;
        case 'escape':
            if (state.onboardingVisible) {
                closeOnboarding();
            }
            if (state.tourActive) {
                stopTour();
            }
            break;
        case '+':
        case '=':
            handleZoom(-1);
            break;
        case '-':
        case '_':
            handleZoom(1);
            break;
    }
});

// Onboarding system
function initOnboarding() {
    const tooltip = document.getElementById('onboardingTooltip');
    const dotsContainer = document.getElementById('tooltipDots');
    
    // Create dots
    onboardingSteps.forEach((_, i) => {
        const dot = document.createElement('span');
        dot.className = 'tooltip-dot';
        if (i === 0) dot.classList.add('active');
        dotsContainer.appendChild(dot);
    });
    
    // Show first step
    updateOnboardingStep(0);
    
    // Show tooltip after a brief delay
    setTimeout(() => {
        tooltip.classList.add('visible');
    }, 1000);
}

function updateOnboardingStep(step) {
    state.onboardingStep = step;
    const stepData = onboardingSteps[step];
    
    document.getElementById('tooltipTitle').innerText = stepData.title;
    document.getElementById('tooltipText').innerText = stepData.text;
    
    // Update dots
    document.querySelectorAll('.tooltip-dot').forEach((dot, i) => {
        dot.classList.toggle('active', i === step);
    });
    
    // Update button states
    document.getElementById('tooltipPrev').disabled = step === 0;
    document.getElementById('tooltipNext').disabled = step === onboardingSteps.length - 1;
}

function toggleOnboarding() {
    state.onboardingVisible = !state.onboardingVisible;
    const tooltip = document.getElementById('onboardingTooltip');
    tooltip.classList.toggle('visible', state.onboardingVisible);
}

function closeOnboarding() {
    state.onboardingVisible = false;
    document.getElementById('onboardingTooltip').classList.remove('visible');
}

document.getElementById('tooltipClose').addEventListener('click', closeOnboarding);

document.getElementById('tooltipPrev').addEventListener('click', () => {
    if (state.onboardingStep > 0) {
        updateOnboardingStep(state.onboardingStep - 1);
    }
});

document.getElementById('tooltipNext').addEventListener('click', () => {
    if (state.onboardingStep < onboardingSteps.length - 1) {
        updateOnboardingStep(state.onboardingStep + 1);
    } else {
        closeOnboarding();
    }
});

// Auto-tour functionality
const tourLocations = ['default', 'seahorse', 'elephant', 'spiral', 'minibrot'];
let tourTimeout = null;

function startTour() {
    state.tourActive = true;
    state.tourStep = 0;
    document.getElementById('tourLabel').innerText = 'Stop';
    document.getElementById('autoTourBtn').classList.add('active');
    tourNextLocation();
}

function stopTour() {
    state.tourActive = false;
    document.getElementById('tourLabel').innerText = 'Tour';
    document.getElementById('autoTourBtn').classList.remove('active');
    if (tourTimeout) {
        clearTimeout(tourTimeout);
        tourTimeout = null;
    }
}

function tourNextLocation() {
    if (!state.tourActive) return;
    
    const locationKey = tourLocations[state.tourStep];
    const loc = locations[locationKey];
    
    state.isAnimating = true;
    state.velocity = { x: 0, y: 0 };
    state.targetZoomCenter = { x: loc.x, y: loc.y };
    state.targetZoomSize = loc.size;
    
    document.getElementById('locationSelect').value = locationKey;
    updateLocationStory(locationKey);
    
    state.tourStep = (state.tourStep + 1) % tourLocations.length;
    
    tourTimeout = setTimeout(() => {
        state.isAnimating = false;
        tourTimeout = setTimeout(tourNextLocation, 3000);
    }, 2000);
}

document.getElementById('autoTourBtn').addEventListener('click', () => {
    if (state.tourActive) {
        stopTour();
    } else {
        startTour();
    }
});

// Debounced resize handler
let resizeTimeout = null;
window.addEventListener('resize', () => {
    if (resizeTimeout) clearTimeout(resizeTimeout);
    resizeTimeout = setTimeout(() => {
        // Force canvas resize on next frame
        resizeCanvasToDisplaySize(gl.canvas);
    }, 150);
});

// Initialize UI
if (checkWebGLCapabilities()) {
    updateLegendGradient();
    updateLocationStory('default');
    initOnboarding();

    // Start Loop
    animationFrameId = requestAnimationFrame(drawScene);
}

